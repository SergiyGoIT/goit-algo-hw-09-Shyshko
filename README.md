Аналіз ефективності алгоритмів для видачі решти

Завдання

Реалізовано дві функції для видачі решти покупцеві за допомогою набору монет [50, 25, 10, 5, 2, 1]:

Жадібний алгоритм (find_coins_greedy).
Алгоритм динамічного програмування (find_min_coins).
Обидві функції повертають словник із номіналами монет та їх кількістю для формування заданої суми. Наприклад, для суми 113 результат: {50: 2, 10: 1, 2: 1, 1: 1}.

Порівняння ефективності
Жадібний алгоритм
Складність: O(n), де n — кількість номіналів монет (у нашому випадку 6).
Як працює: Завжди вибирає найбільший номінал, що не перевищує залишкову суму. Проходить список монет один раз.
Переваги:
Дуже швидкий, бо виконує мінімальну кількість операцій.
Простий у реалізації та розумінні.
Недоліки:
Не завжди дає оптимальний результат. Наприклад, для набору монет [4, 3, 1] і суми 6 жадібний алгоритм вибере 4+1+1 (3 монети), хоча оптимально 3+3 (2 монети).
Для нашого набору [50, 25, 10, 5, 2, 1] працює оптимально, бо номінали добре підібрані.

Алгоритм динамічного програмування
Складність: O(amount * n), де amount — сума, а n — кількість номіналів монет.
Як працює: Будує таблицю, яка зберігає мінімальну кількість монет для кожної суми від 0 до amount. Для кожної суми перевіряє всі можливі монети.
Переваги:
Гарантує мінімальну кількість монет для будь-якого набору номіналів.
Надійний для складних випадків, де жадібний алгоритм не працює.
Недоліки:
Повільніший за жадібний алгоритм, особливо для великих сум, бо перевіряє багато комбінацій.
Вимагає більше пам’яті для зберігання таблиці dp.

Порівняння для великих сум
Жадібний алгоритм:
Час виконання не залежить від розміру суми, лише від кількості номіналів. Для суми 1,000,000 він так само швидкий, як для суми 10.
Але якщо номінали монет будуть нестандартними (наприклад, [4, 3, 1]), може дати неоптимальний результат.
Динамічне програмування:
Час виконання зростає пропорційно до суми. Для суми 1,000,000 алгоритм буде значно повільнішим, бо потрібно заповнити масив розміром 1,000,001.
Завжди дає оптимальний результат, але це може бути невиправдано для нашого набору монет, де жадібний алгоритм уже оптимальний.
Висновки
Для набору монет [50, 25, 10, 5, 2, 1] жадібний алгоритм є кращим, бо:
Він значно швидший (O(n) проти O(amount * n)).
Дає оптимальний результат для цього набору номіналів.
Простий у реалізації, що важливо для касової системи, де швидкість критична.
Динамічне програмування варто використовувати, якщо:
Номінали монет нестандартні, і жадібний алгоритм може дати неоптимальний результат.
Потрібна гарантія мінімальної кількості монет за будь-яких умов.
Для касової системи, яка працює з великими сумами і стандартними номіналами, жадібний алгоритм є більш ефективним через швидкість і простоту.
